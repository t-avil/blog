<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PROJECT: Post-Quantum Cryptography in Meshtastic | T|A</title><meta name=keywords content="project,esp32,lora,meshtastic,post-quantum cryptography,kyber,quantum-safe,iot security,embedded systems,off-grid communication,mesh networks,resource-constrained devices,encryption performance"><meta name=description content="How I Stuffed Kyber Into an ESP32."><meta name=author content="Me"><link rel=canonical href=https://canonical.url/to/page><link crossorigin=anonymous href=/assets/css/stylesheet.3f7ba6a00d316a1658af1e52b60f5592bfd3f63e1683217d447958625c9fec2a.css integrity="sha256-P3umoA0xahZYrx5Stg9Vkr/T9j4WgyF9RHlYYlyf7Co=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/micro-pq-crypt-for-lora/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/micro-pq-crypt-for-lora/"><meta property="og:site_name" content="T|A"><meta property="og:title" content="PROJECT: Post-Quantum Cryptography in Meshtastic"><meta property="og:description" content="How I Stuffed Kyber Into an ESP32."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-04T02:21:17-07:00"><meta property="article:modified_time" content="2025-09-04T02:21:17-07:00"><meta property="article:tag" content="Project"><meta property="article:tag" content="Esp32"><meta property="article:tag" content="Lora"><meta property="article:tag" content="Meshtastic"><meta property="article:tag" content="Post-Quantum Cryptography"><meta property="article:tag" content="Kyber"><meta property="og:image" content="http://localhost:1313/images/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/images/papermod-cover.png"><meta name=twitter:title content="PROJECT: Post-Quantum Cryptography in Meshtastic"><meta name=twitter:description content="How I Stuffed Kyber Into an ESP32."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"PROJECT: Post-Quantum Cryptography in Meshtastic","item":"http://localhost:1313/posts/micro-pq-crypt-for-lora/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PROJECT: Post-Quantum Cryptography in Meshtastic","name":"PROJECT: Post-Quantum Cryptography in Meshtastic","description":"How I Stuffed Kyber Into an ESP32.","keywords":["project","esp32","lora","meshtastic","post-quantum cryptography","kyber","quantum-safe","iot security","embedded systems","off-grid communication","mesh networks","resource-constrained devices","encryption performance"],"articleBody":" Meshtastic (lora) firs message over quantum encryption\nThis post explains how I integrated post-quantum cryptography into Meshtastic firmware. Specifically, I replaced the classical Curve25519 key exchange with Kyber-512, a lattice-based key encapsulation mechanism, while maintaining compatibility with legacy nodes. I specifically wanted to apply this research paper and see how the system wil behave with a couple of mesh nodes upgraded.\nAlong the way, I will explain the components: Meshtastic, LoRa, and the ESP32, and provide references to two recent research papers that explore PQ cryptography in IoT contexts.\nBy the end, readers should understand why post-quantum cryptography matters for mesh networks and how it can run even on tiny embedded devices.\nWhat is Meshtastic Meshtastic is an open-source mesh network firmware for off-grid, low-power communication. A mesh network is a decentralized network where every node can communicate with nearby nodes and forward messages for distant nodes. This makes it ideal for outdoor adventures, emergency communication, or any situation without cell towers.\nMeshtastic nodes usually consist of a microcontroller, typically the ESP32, paired with a LoRa radio for long-range communication.\nLoRa: Long-Range Radio Technology LoRa stands for Long Range. It is a radio modulation technique designed for low-power, long-distance communication. Unlike Wi-Fi or Bluetooth, LoRa can transmit small amounts of data over several kilometers while using very little battery.\nLoRa is ideal for mesh networks because:\nIt tolerates noisy environments Nodes can forward messages to neighbors, forming multi-hop networks It minimizes bandwidth usage, making it compatible with constrained microcontrollers ESP32: The Embedded Brain The ESP32 is a small, low-cost microcontroller that includes:\nA dual-core processor (tens of megahertz range) Wi-Fi and Bluetooth radios Hardware acceleration for cryptographic algorithms like AES and SHA Limited RAM and flash memory This makes it powerful enough to run complex algorithms like Kyber, but we have to manage memory and CPU carefully.\nRecent research has shown that Kyber can be semi-efficiently implemented on ESP32 by hand-partitioning the algorithm across its dual cores and leveraging cryptographic coprocessors. This improves execution time significantly. See Efficient Kyber on ESP32.\nThe Quantum Threat Modern public-key cryptography like Curve25519 relies on mathematical problems that classical computers find hard to solve. But quantum computers can solve these problems quickly using algorithms like Shor’s algorithm.\nThis puts all ECC-based key exchanges at risk.\nPost-quantum cryptography (PQC) uses problems that quantum computers cannot solve efficiently. For example, Kyber relies on lattice problems that are believed to be quantum-resistant.\nOne challenge is that PQC can be computationally heavy, which matters for tiny IoT devices like ESP32. A recent survey explores the performance of PQC on constrained devices and emphasizes the need for optimization standards. See PQC in Resource-Constrained IoT.\nClassical Meshtastic Encryption Before PQC, Meshtastic used:\nAES-256 for message encryption Curve25519 for key exchange Pre-shared keys for channel encryption Flow:\n1. Node A generates Curve25519 keypair 2. Node A shares public key with Node B 3. Node B computes shared secret using ECDH 4. Derive AES session key 5. Encrypt message 6. Send message with authentication tag This is fast and efficient but vulnerable to quantum attacks.\nAdding Kyber-512 Kyber-512 is a lattice-based KEM that provides ~128-bit security against both classical and quantum attacks. Key sizes are larger than Curve25519:\nPublic key: 800 bytes Private key: 1632 bytes Ciphertext: 768 bytes Shared secret: 32 bytes To fit these keys into LoRa packets, we fragment them into smaller pieces (~200 bytes each) and reassemble them on the receiving node.\nEncryption flow:\n1. Node A generates Kyber keypair 2. Node A broadcasts PQ capability 3. Node A sends key fragments 4. Node B reassembles fragments and verifies hash 5. Node B performs Kyber encapsulation to derive shared secret 6. Derive AES session key from shared secret 7. Encrypt message 8. Send encrypted payload with Kyber ciphertext fragment Hybrid Crypto Engine To maintain compatibility with older nodes, Meshtastic now runs two crypto systems in parallel:\nclass CryptoEngine { bool encryptCurve25519(...); bool encryptKyber(...); bool decryptCurve25519(...); bool decryptKyber(...); uint8_t pq_public_key[800]; uint8_t pq_private_key[1632]; }; The router decides at runtime which method to use based on node capabilities.\nRuntime Encryption Decision In Meshtastic, every outgoing message passes through the Router, which determines which encryption method to use. The decision is made dynamically, based on:\nWhether the sending node has Kyber keys already generated. Whether the receiving node supports post-quantum cryptography (PQ capabilities). Whether the network prefers PQ, falling back to classical Curve25519 if PQ is unavailable. This ensures smooth interoperability, even in a mixed network of legacy and PQ-capable devices.\nExample EncryptionDecision selectEncryption(NodeNum toNode) { NodeInfo* peer = nodeDB-\u003egetMeshNode(toNode); // Broadcast messages or unknown nodes use channel encryption if (!peer || peer-\u003euser.public_key.size == 0) return USE_CHANNEL_ENCRYPTION; bool peerSupportsPQ = (peer-\u003euser.has_pq_capabilities \u0026\u0026 peer-\u003euser.pq_capabilities \u0026 PQ_CAP_KYBER_SUPPORT); bool weHavePQKeys = pqKeyExchangeModule-\u003ehasValidPQKeys(toNode); bool weSupportPQ = crypto-\u003ehasValidKyberKeys(); if (peerSupportsPQ \u0026\u0026 weSupportPQ \u0026\u0026 weHavePQKeys) return USE_PQ_PRIMARY; // Use Kyber-512 else if (peerSupportsPQ \u0026\u0026 weSupportPQ \u0026\u0026 !weHavePQKeys) return INITIATE_PQ_EXCHANGE; // Start key exchange first else return USE_CLASSICAL_PKI; // Fallback to Curve25519 } Node A wants to send a message to Node B. Node B advertises PQ capabilities. Node A already has Kyber keys for Node B. Router chooses USE_PQ_PRIMARY and encrypts the message with Kyber. If Node B didn’t yet have keys, the Router initiates a key exchange while sending messages with classical encryption until the PQ keys are ready. This approach avoids breaking the network mid-transition.\nNarrative Conclusion The journey of integrating post-quantum cryptography into Meshtastic is as much about engineering intuition as it is about algorithms. Each challenge-from oversized keys and memory constraints to out-of-order LoRa fragments-taught lessons that extend beyond this single implementation. We learned that:\nSecurity doesn’t happen in isolation. Memory management, message fragmentation, and CPU scheduling all intersect with cryptography. You can’t just drop in Kyber-512 and expect it to behave. Hybrid systems ease adoption. Running PQ and classical encryption side by side ensures backward compatibility while gradually introducing stronger security. Performance is a negotiation. Every millisecond counts on an ESP32, but careful caching, lazy key exchange, and leveraging dual cores can keep latency within acceptable limits. Every reset is a lesson. Debugging embedded systems often involves unexpected crashes. Each reset forced a closer look at assumptions and helped refine the system into something resilient. Challenges (a.k.a. Things That Made Me Swear at My ESP32) nanopb Shenanigans: Protobuf bytes fields without a size limit = every message allocates an 800-byte buffer. Oops. Fixed with (nanopb).max_size. Stack vs Heap: Kyber eats kilobytes of temporary space. ESP32 task stack ≈ 8KB. I punted to static buffers in .bss to avoid random stack overflows. Performance: Curve25519 runs in \u003c1ms. Kyber keygen = ~47ms, encaps = 8ms, decap = 12ms. Manageable, but caching and lazy exchanges were necessary. Testing Unit tests for crypto roundtrips, fragmentation reassembly, capability negotiation. Multi-node mesh: PQ↔PQ, PQ↔legacy, PQ-only. Benchmarks: +15% RAM usage, ~800B per key exchange, ~764B per PQ packet. Break-even for PQ overhead: ~1.3KB of encrypted messages per peer. Final thoughts The successful deployment of post-quantum cryptography in Meshtastic demonstrates that the quantum-safe future of communications is not merely theoretical, but practically achievable today.\nSo, can you cram post-quantum cryptography into a tiny ESP32 mesh node? Turns out: yes, with enough protobuf hacks, static buffers, and late-night coffee.\nMeshtastic now has a quantum-resistant mode that interoperates seamlessly with classical nodes. It’s not just a proof-of-concept - it’s running in real test meshes.\nThis work is a step toward a future where mesh communications stay private even in the face of quantum computers. And along the way, it proved that PQ crypto isn’t just for servers in datacenters - it can live in low-power radios strapped to your backpack.\nFull code available on this GitHub branch, and way too many comments explaining design decisions. Because if you’re going to overthink a project, you might as well document the overthinking process.\n","wordCount":"1298","inLanguage":"en","image":"http://localhost:1313/images/papermod-cover.png","datePublished":"2025-09-04T02:21:17-07:00","dateModified":"2025-09-04T02:21:17-07:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/micro-pq-crypt-for-lora/"},"publisher":{"@type":"Organization","name":"T|A","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="T|A (Alt + H)">T|A</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about title=About><span>About</span></a></li><li><a href=http://localhost:1313/chronicles title=Chronicles><span>Chronicles</span></a></li><li><a href=http://localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://github.com/t-avil title=Github><span>Github</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">PROJECT: Post-Quantum Cryptography in Meshtastic</h1><div class=post-description>How I Stuffed Kyber Into an ESP32.</div><div class=post-meta><span title='2025-09-04 02:21:17 -0700 PDT'>September 4, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1298 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/t-avil/blog/tree/main/content/posts/micro-pq-crypt-for-lora.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#what-is-meshtastic>What is Meshtastic</a></li><li><a href=#lora-long-range-radio-technology>LoRa: Long-Range Radio Technology</a></li><li><a href=#esp32-the-embedded-brain>ESP32: The Embedded Brain</a></li><li><a href=#the-quantum-threat>The Quantum Threat</a></li><li><a href=#classical-meshtastic-encryption>Classical Meshtastic Encryption</a></li><li><a href=#adding-kyber-512>Adding Kyber-512</a></li><li><a href=#hybrid-crypto-engine>Hybrid Crypto Engine</a><ul><li><a href=#runtime-encryption-decision>Runtime Encryption Decision</a></li><li><a href=#narrative-conclusion>Narrative Conclusion</a></li></ul></li><li><a href=#final-thoughts>Final thoughts</a></li></ul></nav></div></details></div><div class=post-content><figure><img loading=lazy src=/images/micro-pq-crypt-for-lora.jpg><figcaption><p>Meshtastic (lora) firs message over quantum encryption</p></figcaption></figure><p>This post explains how I integrated post-quantum cryptography into Meshtastic firmware. Specifically, I replaced the classical Curve25519 key exchange with <strong>Kyber-512</strong>, a lattice-based key encapsulation mechanism, while maintaining compatibility with legacy nodes. I specifically wanted to apply this <a href=https://arxiv.org/html/2503.10207v1#S4>research paper</a> and see how the system wil behave with a couple of mesh nodes upgraded.<br>Along the way, I will explain the components: <strong>Meshtastic</strong>, <strong>LoRa</strong>, and the <strong>ESP32</strong>, and provide references to two recent research papers that explore PQ cryptography in IoT contexts.</p><p>By the end, readers should understand why post-quantum cryptography matters for mesh networks and how it can run even on tiny embedded devices.</p><h2 id=what-is-meshtastic>What is Meshtastic<a hidden class=anchor aria-hidden=true href=#what-is-meshtastic>#</a></h2><p>Meshtastic is an open-source mesh network firmware for <strong>off-grid, low-power communication</strong>. A mesh network is a decentralized network where every node can communicate with nearby nodes and forward messages for distant nodes. This makes it ideal for outdoor adventures, emergency communication, or any situation without cell towers.</p><p>Meshtastic nodes usually consist of a <strong>microcontroller</strong>, typically the ESP32, paired with a <strong>LoRa radio</strong> for long-range communication.</p><h2 id=lora-long-range-radio-technology>LoRa: Long-Range Radio Technology<a hidden class=anchor aria-hidden=true href=#lora-long-range-radio-technology>#</a></h2><p><strong>LoRa</strong> stands for Long Range. It is a radio modulation technique designed for low-power, long-distance communication. Unlike Wi-Fi or Bluetooth, LoRa can transmit small amounts of data over several kilometers while using very little battery.</p><p>LoRa is ideal for mesh networks because:</p><ul><li>It tolerates noisy environments</li><li>Nodes can forward messages to neighbors, forming multi-hop networks</li><li>It minimizes bandwidth usage, making it compatible with constrained microcontrollers</li></ul><h2 id=esp32-the-embedded-brain>ESP32: The Embedded Brain<a hidden class=anchor aria-hidden=true href=#esp32-the-embedded-brain>#</a></h2><p>The <strong>ESP32</strong> is a small, low-cost microcontroller that includes:</p><ul><li>A dual-core processor (tens of megahertz range)</li><li>Wi-Fi and Bluetooth radios</li><li>Hardware acceleration for cryptographic algorithms like AES and SHA</li><li>Limited RAM and flash memory</li></ul><p>This makes it powerful enough to run complex algorithms like Kyber, but we have to manage memory and CPU carefully.</p><p>Recent research has shown that Kyber can be semi-efficiently implemented on ESP32 by hand-partitioning the algorithm across its dual cores and leveraging cryptographic coprocessors. This improves execution time significantly. See <a href=https://arxiv.org/html/2503.10207v1#S4>Efficient Kyber on ESP32</a>.</p><h2 id=the-quantum-threat>The Quantum Threat<a hidden class=anchor aria-hidden=true href=#the-quantum-threat>#</a></h2><p>Modern public-key cryptography like <strong>Curve25519</strong> relies on mathematical problems that classical computers find hard to solve. But <strong>quantum computers</strong> can solve these problems quickly using algorithms like Shor&rsquo;s algorithm.</p><p>This puts all ECC-based key exchanges at risk.</p><p>Post-quantum cryptography (PQC) uses problems that quantum computers cannot solve efficiently. For example, <strong>Kyber</strong> relies on lattice problems that are believed to be quantum-resistant.</p><p>One challenge is that PQC can be computationally heavy, which matters for tiny IoT devices like ESP32. A recent survey explores the performance of PQC on constrained devices and emphasizes the need for optimization standards. See <a href=https://arxiv.org/html/2401.17538v1>PQC in Resource-Constrained IoT</a>.</p><h2 id=classical-meshtastic-encryption>Classical Meshtastic Encryption<a hidden class=anchor aria-hidden=true href=#classical-meshtastic-encryption>#</a></h2><p>Before PQC, Meshtastic used:</p><ul><li><strong>AES-256</strong> for message encryption</li><li><strong>Curve25519</strong> for key exchange</li><li>Pre-shared keys for channel encryption</li></ul><p>Flow:</p><pre tabindex=0><code>1. Node A generates Curve25519 keypair
2. Node A shares public key with Node B
3. Node B computes shared secret using ECDH
4. Derive AES session key
5. Encrypt message
6. Send message with authentication tag
</code></pre><p>This is fast and efficient but vulnerable to quantum attacks.</p><h2 id=adding-kyber-512>Adding Kyber-512<a hidden class=anchor aria-hidden=true href=#adding-kyber-512>#</a></h2><p>Kyber-512 is a <strong>lattice-based KEM</strong> that provides ~128-bit security against both classical and quantum attacks. Key sizes are larger than Curve25519:</p><ul><li>Public key: 800 bytes</li><li>Private key: 1632 bytes</li><li>Ciphertext: 768 bytes</li><li>Shared secret: 32 bytes</li></ul><p>To fit these keys into LoRa packets, we fragment them into smaller pieces (~200 bytes each) and reassemble them on the receiving node.</p><p>Encryption flow:</p><pre tabindex=0><code>1. Node A generates Kyber keypair
2. Node A broadcasts PQ capability
3. Node A sends key fragments
4. Node B reassembles fragments and verifies hash
5. Node B performs Kyber encapsulation to derive shared secret
6. Derive AES session key from shared secret
7. Encrypt message
8. Send encrypted payload with Kyber ciphertext fragment
</code></pre><h2 id=hybrid-crypto-engine>Hybrid Crypto Engine<a hidden class=anchor aria-hidden=true href=#hybrid-crypto-engine>#</a></h2><p>To maintain compatibility with older nodes, Meshtastic now runs <strong>two crypto systems in parallel</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CryptoEngine</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>encryptCurve25519</span><span class=p>(...);</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>encryptKyber</span><span class=p>(...);</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>decryptCurve25519</span><span class=p>(...);</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>decryptKyber</span><span class=p>(...);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=n>pq_public_key</span><span class=p>[</span><span class=mi>800</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=n>pq_private_key</span><span class=p>[</span><span class=mi>1632</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>The router decides at runtime which method to use based on node capabilities.</p><h3 id=runtime-encryption-decision>Runtime Encryption Decision<a hidden class=anchor aria-hidden=true href=#runtime-encryption-decision>#</a></h3><p>In Meshtastic, every outgoing message passes through the Router, which determines which encryption method to use. The decision is made dynamically, based on:</p><ol><li>Whether the <strong>sending node has Kyber keys</strong> already generated.</li><li>Whether the <strong>receiving node supports post-quantum cryptography</strong> (PQ capabilities).</li><li>Whether the <strong>network prefers PQ</strong>, falling back to classical Curve25519 if PQ is unavailable.</li></ol><p>This ensures smooth interoperability, even in a mixed network of legacy and PQ-capable devices.</p><h4 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>EncryptionDecision</span> <span class=nf>selectEncryption</span><span class=p>(</span><span class=n>NodeNum</span> <span class=n>toNode</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>NodeInfo</span><span class=o>*</span> <span class=n>peer</span> <span class=o>=</span> <span class=n>nodeDB</span><span class=o>-&gt;</span><span class=n>getMeshNode</span><span class=p>(</span><span class=n>toNode</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Broadcast messages or unknown nodes use channel encryption
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>peer</span> <span class=o>||</span> <span class=n>peer</span><span class=o>-&gt;</span><span class=n>user</span><span class=p>.</span><span class=n>public_key</span><span class=p>.</span><span class=n>size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>USE_CHANNEL_ENCRYPTION</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>peerSupportsPQ</span> <span class=o>=</span> <span class=p>(</span><span class=n>peer</span><span class=o>-&gt;</span><span class=n>user</span><span class=p>.</span><span class=n>has_pq_capabilities</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                           <span class=n>peer</span><span class=o>-&gt;</span><span class=n>user</span><span class=p>.</span><span class=n>pq_capabilities</span> <span class=o>&amp;</span> <span class=n>PQ_CAP_KYBER_SUPPORT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>weHavePQKeys</span> <span class=o>=</span> <span class=n>pqKeyExchangeModule</span><span class=o>-&gt;</span><span class=n>hasValidPQKeys</span><span class=p>(</span><span class=n>toNode</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>weSupportPQ</span> <span class=o>=</span> <span class=n>crypto</span><span class=o>-&gt;</span><span class=n>hasValidKyberKeys</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>peerSupportsPQ</span> <span class=o>&amp;&amp;</span> <span class=n>weSupportPQ</span> <span class=o>&amp;&amp;</span> <span class=n>weHavePQKeys</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>USE_PQ_PRIMARY</span><span class=p>;</span>         <span class=c1>// Use Kyber-512
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>peerSupportsPQ</span> <span class=o>&amp;&amp;</span> <span class=n>weSupportPQ</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>weHavePQKeys</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>INITIATE_PQ_EXCHANGE</span><span class=p>;</span>  <span class=c1>// Start key exchange first
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>USE_CLASSICAL_PKI</span><span class=p>;</span>     <span class=c1>// Fallback to Curve25519
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><ul><li>Node A wants to send a message to Node B.</li><li>Node B advertises PQ capabilities.</li><li>Node A already has Kyber keys for Node B.</li><li>Router chooses <strong>USE_PQ_PRIMARY</strong> and encrypts the message with Kyber.</li></ul><p>If Node B didn’t yet have keys, the Router initiates a key exchange while sending messages with classical encryption until the PQ keys are ready. This approach avoids breaking the network mid-transition.</p><hr><h3 id=narrative-conclusion>Narrative Conclusion<a hidden class=anchor aria-hidden=true href=#narrative-conclusion>#</a></h3><p>The journey of integrating post-quantum cryptography into Meshtastic is as much about engineering intuition as it is about algorithms. Each challenge-from oversized keys and memory constraints to out-of-order LoRa fragments-taught lessons that extend beyond this single implementation. We learned that:</p><ol><li><strong>Security doesn’t happen in isolation</strong>. Memory management, message fragmentation, and CPU scheduling all intersect with cryptography. You can’t just drop in Kyber-512 and expect it to behave.</li><li><strong>Hybrid systems ease adoption</strong>. Running PQ and classical encryption side by side ensures backward compatibility while gradually introducing stronger security.</li><li><strong>Performance is a negotiation</strong>. Every millisecond counts on an ESP32, but careful caching, lazy key exchange, and leveraging dual cores can keep latency within acceptable limits.</li><li><strong>Every reset is a lesson</strong>. Debugging embedded systems often involves unexpected crashes. Each reset forced a closer look at assumptions and helped refine the system into something resilient.</li></ol><h4 id=challenges-aka-things-that-made-me-swear-at-my-esp32>Challenges (a.k.a. Things That Made Me Swear at My ESP32)<a hidden class=anchor aria-hidden=true href=#challenges-aka-things-that-made-me-swear-at-my-esp32>#</a></h4><ol><li>nanopb Shenanigans: Protobuf bytes fields without a size limit = every message allocates an 800-byte buffer. Oops. Fixed with (nanopb).max_size.</li><li>Stack vs Heap: Kyber eats kilobytes of temporary space. ESP32 task stack ≈ 8KB. I punted to static buffers in .bss to avoid random stack overflows.</li><li>Performance: Curve25519 runs in &lt;1ms. Kyber keygen = ~47ms, encaps = 8ms, decap = 12ms. Manageable, but caching and lazy exchanges were necessary.</li></ol><h4 id=testing>Testing<a hidden class=anchor aria-hidden=true href=#testing>#</a></h4><ol><li>Unit tests for crypto roundtrips, fragmentation reassembly, capability negotiation.</li><li>Multi-node mesh: PQ↔PQ, PQ↔legacy, PQ-only.</li><li>Benchmarks: +15% RAM usage, ~800B per key exchange, ~764B per PQ packet.
Break-even for PQ overhead: ~1.3KB of encrypted messages per peer.</li></ol><hr><h2 id=final-thoughts>Final thoughts<a hidden class=anchor aria-hidden=true href=#final-thoughts>#</a></h2><p>The successful deployment of post-quantum cryptography in Meshtastic demonstrates that the quantum-safe future of communications is not merely theoretical, but practically achievable today.</p><p>So, can you cram post-quantum cryptography into a tiny ESP32 mesh node? Turns out: yes, with enough protobuf hacks, static buffers, and late-night coffee.</p><p>Meshtastic now has a quantum-resistant mode that interoperates seamlessly with classical nodes. It’s not just a proof-of-concept - it’s running in real test meshes.</p><p>This work is a step toward a future where mesh communications stay private even in the face of quantum computers. And along the way, it proved that PQ crypto isn’t just for servers in datacenters - it can live in low-power radios strapped to your backpack.</p><hr><p><em>Full code available on this <a href=https://github.com/t-avil/meshtastic-firmware-pq/tree/pq-introduction>GitHub branch</a>, and way too many comments explaining design decisions. Because if you&rsquo;re going to overthink a project, you might as well document the overthinking process.</em></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/project/>Project</a></li><li><a href=http://localhost:1313/tags/esp32/>Esp32</a></li><li><a href=http://localhost:1313/tags/lora/>Lora</a></li><li><a href=http://localhost:1313/tags/meshtastic/>Meshtastic</a></li><li><a href=http://localhost:1313/tags/post-quantum-cryptography/>Post-Quantum Cryptography</a></li><li><a href=http://localhost:1313/tags/kyber/>Kyber</a></li><li><a href=http://localhost:1313/tags/quantum-safe/>Quantum-Safe</a></li><li><a href=http://localhost:1313/tags/iot-security/>Iot Security</a></li><li><a href=http://localhost:1313/tags/embedded-systems/>Embedded Systems</a></li><li><a href=http://localhost:1313/tags/off-grid-communication/>Off-Grid Communication</a></li><li><a href=http://localhost:1313/tags/mesh-networks/>Mesh Networks</a></li><li><a href=http://localhost:1313/tags/resource-constrained-devices/>Resource-Constrained Devices</a></li><li><a href=http://localhost:1313/tags/encryption-performance/>Encryption Performance</a></li></ul><nav class=paginav><a class=next href=http://localhost:1313/posts/searching-the-unsearchable/><span class=title>Next »</span><br><span>NOTES: Searching the unsearchable</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>T|A</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>