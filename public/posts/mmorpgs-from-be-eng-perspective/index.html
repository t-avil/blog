<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>NOTES: MMORPGs From BE Eng Perspective | T|A</title><meta name=keywords content="notes,game-dev,mmorpg,netcode,edge-computing,spatial-partitioning,cloth,backend"><meta name=description content="A technical, continuous train-of-thought on building an MMO backend: edge computing, server topologies and authority, clock sync, spatial partitioning with quadtrees, and a deep dive into cloth sync."><meta name=author content="Me"><link rel=canonical href=https://canonical.url/to/page><link crossorigin=anonymous href=/assets/css/stylesheet.3f7ba6a00d316a1658af1e52b60f5592bfd3f63e1683217d447958625c9fec2a.css integrity="sha256-P3umoA0xahZYrx5Stg9Vkr/T9j4WgyF9RHlYYlyf7Co=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/mmorpgs-from-be-eng-perspective/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/mmorpgs-from-be-eng-perspective/"><meta property="og:site_name" content="T|A"><meta property="og:title" content="NOTES: MMORPGs From BE Eng Perspective"><meta property="og:description" content="A technical, continuous train-of-thought on building an MMO backend: edge computing, server topologies and authority, clock sync, spatial partitioning with quadtrees, and a deep dive into cloth sync."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-05T14:42:25-07:00"><meta property="article:modified_time" content="2025-03-05T14:42:25-07:00"><meta property="article:tag" content="Notes"><meta property="article:tag" content="Game-Dev"><meta property="article:tag" content="Mmorpg"><meta property="article:tag" content="Netcode"><meta property="article:tag" content="Edge-Computing"><meta property="article:tag" content="Spatial-Partitioning"><meta property="og:image" content="http://localhost:1313/images/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/images/papermod-cover.png"><meta name=twitter:title content="NOTES: MMORPGs From BE Eng Perspective"><meta name=twitter:description content="A technical, continuous train-of-thought on building an MMO backend: edge computing, server topologies and authority, clock sync, spatial partitioning with quadtrees, and a deep dive into cloth sync."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"NOTES: MMORPGs From BE Eng Perspective","item":"http://localhost:1313/posts/mmorpgs-from-be-eng-perspective/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"NOTES: MMORPGs From BE Eng Perspective","name":"NOTES: MMORPGs From BE Eng Perspective","description":"A technical, continuous train-of-thought on building an MMO backend: edge computing, server topologies and authority, clock sync, spatial partitioning with quadtrees, and a deep dive into cloth sync.","keywords":["notes","game-dev","mmorpg","netcode","edge-computing","spatial-partitioning","cloth","backend"],"articleBody":" Building an MMORPG backend is like building a tiny distributed country where every player is a citizen, every NPC a bureaucrat, and latency is the weather. You design for scale, consistency, fairness, and - most importantly - fun. Below is one continuous, slightly nerdy walkthrough of the system-level decisions I’d make (and the gotchas I’d sweat about at 3 AM): edge compute, server topologies and authority, clock synchronization, spatial partitioning with quadtrees, and a focused deep-dive on cloth synchronization (yes, that ugly yet sexy problem).\nNote: some concepts and short references below mirror the “lag reduction” notes I carried into the project (edge/local zone patterns, load balancing strategies, lockstep vs rollback, client/server authority, etc.). The shape of the problem: correctness vs responsiveness Before we design anything: an MMO must answer two competing demands:\nCorrectness (authoritative state) - players shouldn’t be able to cheat by lying about their position or health. Responsiveness (feel) - actions should feel instant even when your RTT is non-zero. Solving both means a layered approach: authoritative servers + client prediction + smart networked correction + edge placement.\nEdge computing: bring the server to the player Edge compute reduces RTT by moving session-affine services closer to players. Practical building blocks:\nLocal Zones / Outposts: run full or partial game services in AWS Local Zones or Outposts when low-latency presence is needed in a metro. Useful for voice, matchmaking, and session brokering. Netflix OCAs-style appliances / on-prem edges: for very large events or regions with special constraints, local appliances can cache assets and reduce WAN hops. Edge responsibilities:\nSession brokering \u0026 matchmaking (global service that picks a nearby edge host). Proximity servers - short-lived, regionally spawned authoritative instances for combat zones, raids, or sharded areas. Stateless frontends (auth, cosmetic inventory, marketplace) can run at the cloud edge with global DBs; heavy simulation runs on local stateful nodes. Edge placement minimizes RTT for the critical loops (player input → server tick → response) while leaving durable, global services in centralized regions.\nServer topologies \u0026 authority modes There are multiple topologies. Pick one (or mix them) based on game mechanics:\nCentral authoritative servers (classic)\nSingle authoritative instance per game region/zone. Pros: simple consistency; server enforces rules. Cons: higher latency for distant players; scaling by adding more regions/instances. Sharded / zoning (cell-based)\nThe world is split into shards / cells; each cell has an authoritative server. Players move between cells (handoff). Cells can be assigned by a control plane (quadtrees, see below). Pros: horizontal scaling, locality. Cons: handoff complexity and cross-cell consistency. Client-authoritative with server reconciliation (not for PvP)\nClients lead; servers validate. Good for low-cheat-risk elements like cosmetic sims. Not recommended for combat. P2P / hybrid\nRare for MMOs due to trust/cheat surface. Often used for LAN/low-latency co-op. Relay / regional authority\nClients connect to a local relay that aggregates inputs and forwards to a regional authority - useful when you want to reduce global WAN bandwidth but maintain a single authoritative state. Authority settings determine who finalizes state for a given domain:\nServer-authoritative for game-critical things (position for hit detection, inventories, combat). Client-predicted, server-validated for movement: client shows immediate movement, server later corrects. Client-authoritative for purely cosmetic, local-only simulations (local cloth visual only if correctness not required). Clock synchronization \u0026 ticks: making time meaningful Time is the lingua franca of multiplayer. You need consistent ticks, determinism where possible, and latency-aware mapping.\nTick model Server tick is the canonical clock (e.g., 20-60Hz depending on simulation fidelity). Every authoritative simulation step runs at server tick T. Client tick runs at a higher rate for rendering and local input sampling. Clients map server ticks to local time using periodic server snapshots with server timestamp S_ts and server tick S_tick. Client computes clock_offset = local_now - S_ts - network_latency_estimate/2 and uses it to align.\nTime synchronization techniques Ping/Pong RTT estimation (NTP style): measure RTT and estimate one-way delay; maintain offset with exponential smoothing. This is the simplest and often sufficient. Adaptive smoothing / Kalman filters to stabilize jittery latency. PTP-like methods for tighter sync if hosts are on the same LAN or data center - rarely practical across the public internet. Logical clocks \u0026 sequence numbers for ordering events (tx_id style) when absolute wall-clock sync is not required. Using clocks for networking Server-side authoritative timestamping: server stamps accepted inputs with server_tick and broadcasts snapshots keyed by tick. Client interpolation / extrapolation: client renders server snapshot for tick T - buffer (buffer = 1-3 ticks) and interpolates between ticks to hide jitter. For fast actions, client extrapolates forward (prediction) and later reconciles with authoritative corrections. Pseudo timeline for client:\nReceive snapshot for server_tick T at local time R. render_target_tick = latest_server_tick - render_buffer. Interpolate between snapshots for render_target_tick. Network techniques: interpolation, extrapolation, and rollback Interpolation: keep a short buffer and interpolate between known states. Great for position smoothing, avoids visible teleporting on low packet loss. Extrapolation / prediction: client simulates forward using local inputs. Server corrects if divergence exceeds threshold (snapback or smooth correction). Rollback (for deterministic sims / lockstep games): store history of local inputs and simulation states, apply late-arriving inputs by rolling simulation forward - used in fighting games and lockstep RTS when determinism is strict. For MMOs, rollback is expensive due to state size, so we usually use reconciliation instead. Lockstep vs rollback vs server-authoritative:\nLockstep (deterministic): all peers run the same deterministic sim and exchange inputs. Low bandwidth but needs bit-exact determinism - hard for cloth and physics. Rollback: apply late inputs retroactively; requires checkpointing and often used in peer-fighting games. Server-authoritative with client prediction + reconciliation: most robust for MMO scale. Spatial partitioning: quadtrees, sharding, and interest management Partitioning the world by location is essential for scaling and interest management.\nQuadtrees for location-based partitioning Quadtrees recursively subdivide space into four quadrants until each leaf contains a manageable number of entities or covers a small area. Use-cases:\nInterest management: query quadtree for radius or view-frustum to determine which entities a client needs. Server sharding: map quadtree leaves to authoritative servers or worker pools. When a leaf grows too hot, split it; when sparse, merge. Load balancing: use heatmaps to migrate hot leaves to more provisioned hosts. Quadtrees are simple and spatially adaptive. Implementation notes:\nUse loose quadtrees to avoid thrashing entities across boundaries. Store metadata per node: entity count, CPU load estimate, bandwidth usage. Handoff when a player crosses a node boundary: a short “handoff protocol” transfers authority and state and uses overlap regions during handoff to prevent gaps. Interest management \u0026 multicast Compute a relevance set per client using quadtree queries + LOD rules (NPCs beyond X meters get less frequent updates). Use multicast groups or topic-based pub/sub to only send deltas to clients that care (spatial topics like zone/leaf/123). Server-side simulation: partitioning \u0026 authority strategies How to split simulation responsibilities:\nCell servers: authoritative for a spatial cell; responsible for physics \u0026 authoritative gameplay. Service workers: handle non-latency-critical tasks - AI pathfinding batch jobs, economy processing, persistence. Replica/reader nodes: read-only copies for analytics, leaderboards, or for cheap, eventual-consistent queries. When scaling, prefer stateful cells + stateless frontends. Cells are sticky to players; frontends route input to the correct cell. A matchmaking/control plane assigns cells and manages lifecycle.\nLoad balancing \u0026 provisioning modes From the slide notes: choose servers based on usage profile - reserved, on-demand, spot - and plan for autoscaling \u0026 pre-warming:\nReserved servers for persistent high-capacity regions/peak hours. On-demand for elasticity. Spot instances for cheap but replaceable workers (non-critical batch processing, analytics). Pre-warming or warm pools for game instances that must start fast (avoid spin-up latency during a raid). Load balancers should be proximity-aware and sticky at the session level when needed, but not for authoritative instances that must reject unauthenticated reroutes.\n(See the “lag reduction” notes for a reminder that load balancing and edge placement are cornerstones of latency reduction.) Cloth sync - deep dive (the spicy one) Cloth simulation is tricky: it’s high-frequency, high-degree-of-freedom, and visually sensitive. You usually cannot naively stream per-vertex positions from server to clients - bandwidth explodes. Here’s a practical, layered strategy.\n1) Decide the authority model for cloth Options:\nClient-only (visual-only) - the server ignores cloth entirely. Good for cosmetics where gameplay is unaffected. Server-authoritative physics - server runs cloth sim and sends authoritative states; needed if cloth affects gameplay (e.g., entanglement, hitboxes). Hybrid - server authorizes key constraints/anchors; clients run local sims for rendering and reconcile to authoritative constraints. For MMORPGs, hybrid is usually the sweet spot: server maintains anchors and critical collisions; clients predict local cloth motion for smooth visuals.\n2) Represent cloth efficiently Network transfers should avoid per-frame full-vertex dumps. Use these techniques:\nAnchor/constraint sync: send only anchor points and constraint updates (rest lengths, impulses). Clients simulate cloth locally using those anchors. Lodded vertex sets: send a high-frequency small core set of “driver” vertices and low-frequency deltas for the rest. Principal component / PCA compression: encode cloth frames in a low-rank basis (approximate by a few coefficients per frame). Great if cloth moves in a constrained manner (capes, flags). Delta + predictive coding: send deltas relative to predicted local sim to save bandwidth. 3) Determinism vs stochasticity Use fixed timestep local sims (e.g., 120Hz physics loop) and deterministic integrators (semi-implicit Euler, Verlet with fixed order) so client sim mirrors server sim as closely as possible. Use shared RNG seed for stochastic forces (wind gusts) so clients and server can reproduce pseudo-random influences deterministically. 4) Correction \u0026 reconciliation Even with careful design, client sim drifts. Reconciliation strategy:\nAuthority snapshots: server sends periodic authoritative “keyframes” with a server_tick timestamp and a small correction envelope. Blend corrections: clients smoothly blend from local state to authoritative state over k frames rather than snapping. Use velocity-preserving blends when possible to avoid pops. Constraint projection: server sends constraint corrections (e.g., anchor position corrections or per-constraint stretching penalties). Clients apply these as impulses rather than overwriting positions. Snippet (pseudo) for client correction blend:\n// acolor: authoritative positions; local: predicted for i in 0..num_verts: delta = authoritative[i] - local[i] local[i] += delta * clamp( alpha, 0, 1 ) // alpha small, e.g., 0.1 5) Multi-resolution streaming High-prio: anchor vertices, collision-critical verts (near player weapon), per-frame. Mid-prio: silhouette vertices, every N frames. Low-prio: interior vertices, sparse updates or PCA-coded updates. 6) Bandwidth estimate \u0026 sampling Tune:\nAnchor-only mode: few KB/s per cloth. Full per-vertex sync (bad): MB/s per client. PCA/delta approach: tens to hundreds of KB/s depending on frequency. 7) Example hybrid workflow Server computes anchor positions + collision impulses each authoritative tick. Clients simulate local cloth at render rate, sampling server anchors on arrival. On authoritative tick, server sends corrections for anchors \u0026 important constraints; clients apply blended corrections. Periodic keyframes (vector-compressed or PCA) re-sync full shape if drift exceeds threshold. This gets visually-close cloth with manageable bandwidth and server CPU. If cloth affects gameplay, raise server tick and authority; if cosmetic, favor client-only sim and occasional server nudges.\nPractical network patterns \u0026 conservative heuristics Interest-based update frequency: players near a cloth source get full updates; distant players get coarse LOD. Thresholded corrections: only send full state if drift \u003e epsilon. Predictive drift compensation: server provides velocity/acceleration for anchors so clients can predict until next update. Compression + binary protocols: use compact binary frames (VarInt, delta-encoding) and consider protocol buffers / custom COBS to minimize packets. Persistence, reconcilation \u0026 authoritative storage For MMO scale, persistence strategy:\nAuthoritative snapshots persisted periodically (checkpoints) to durable storage. Event sourcing for important game mutations (player trades, inventory changes) so you can replay and backfill. Soft state for visuals such as cloth usually does not persist beyond session, unless tied to gameplay. Backfills and rollbacks must be deterministic and replayable. If a shard fails, replay CDC-like event logs to bring replicas up-to-date.\nMonitoring \u0026 metrics to watch closely Server tick time (ms) and drops (missed ticks). Network jitter \u0026 packet loss per client region. State divergence metrics (client vs server error histograms). Memory use for state backends (e.g., per-cell cloth cache). Hotspot detection to trigger dynamic quadtree splits. TL;DR: architecture checklist Use edge/local zones for low-latency session brokering and proximity servers. Pick server topology: cell-based authoritative servers + stateless frontends is a pragmatic choice. Sync time by server ticks + ping-based offset estimation; render with interpolation and prediction. Partition world with loose quadtrees for adaptive sharding and interest management. Build handoff protocols for smooth cross-node migration. For cloth: prefer hybrid authority (anchors server, local sim client), compress state (anchor-only, PCA, deltas), and reconcile with blended corrections. Use reserved + on-demand + spot provisioning strategies and warm pools for fast scaling. Final note (real talk) The art of MMO backend engineering is picking the parts you can operationally own. Don’t try to make every system deterministic across all edge cases - instead, identify what must be right (combat hits, inventory), what must feel right (movement, cloth, VFX), and what can be eventual (leaderboards, analytics). Combine server-authoritative systems for correctness with prediction and local sims for feel. Use edge compute and quadtrees for locality. Make cloth a hybrid problem: clever compression + deterministic cores + smooth corrections. And, most importantly, instrument everything - your best sleep comes from good metrics, not superstition.\n","wordCount":"2190","inLanguage":"en","image":"http://localhost:1313/images/papermod-cover.png","datePublished":"2025-03-05T14:42:25-07:00","dateModified":"2025-03-05T14:42:25-07:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/mmorpgs-from-be-eng-perspective/"},"publisher":{"@type":"Organization","name":"T|A","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="T|A (Alt + H)">T|A</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about title=About><span>About</span></a></li><li><a href=http://localhost:1313/chronicles title=Chronicles><span>Chronicles</span></a></li><li><a href=http://localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://github.com/t-avil title=Github><span>Github</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">NOTES: MMORPGs From BE Eng Perspective</h1><div class=post-description>A technical, continuous train-of-thought on building an MMO backend: edge computing, server topologies and authority, clock sync, spatial partitioning with quadtrees, and a deep dive into cloth sync.</div><div class=post-meta><span title='2025-03-05 14:42:25 -0700 -0700'>March 5, 2025</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2190 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/t-avil/blog/tree/main/content/posts/mmorpgs-from-be-eng-perspective.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#the-shape-of-the-problem-correctness-vs-responsiveness>The shape of the problem: correctness vs responsiveness</a></li><li><a href=#edge-computing-bring-the-server-to-the-player>Edge computing: bring the server to the player</a></li><li><a href=#server-topologies--authority-modes>Server topologies & authority modes</a></li><li><a href=#clock-synchronization--ticks-making-time-meaningful>Clock synchronization & ticks: making time meaningful</a><ul><li><a href=#tick-model>Tick model</a></li><li><a href=#time-synchronization-techniques>Time synchronization techniques</a></li><li><a href=#using-clocks-for-networking>Using clocks for networking</a></li></ul></li><li><a href=#network-techniques-interpolation-extrapolation-and-rollback>Network techniques: interpolation, extrapolation, and rollback</a></li><li><a href=#spatial-partitioning-quadtrees-sharding-and-interest-management>Spatial partitioning: quadtrees, sharding, and interest management</a><ul><li><a href=#quadtrees-for-location-based-partitioning>Quadtrees for location-based partitioning</a></li><li><a href=#interest-management--multicast>Interest management & multicast</a></li></ul></li><li><a href=#server-side-simulation-partitioning--authority-strategies>Server-side simulation: partitioning & authority strategies</a></li><li><a href=#load-balancing--provisioning-modes>Load balancing & provisioning modes</a></li><li><a href=#cloth-sync---deep-dive-the-spicy-one>Cloth sync - deep dive (the spicy one)</a><ul><li><a href=#1-decide-the-authority-model-for-cloth>1) Decide the authority model for cloth</a></li><li><a href=#2-represent-cloth-efficiently>2) Represent cloth efficiently</a></li><li><a href=#3-determinism-vs-stochasticity>3) Determinism vs stochasticity</a></li><li><a href=#4-correction--reconciliation>4) Correction & reconciliation</a></li><li><a href=#5-multi-resolution-streaming>5) Multi-resolution streaming</a></li><li><a href=#6-bandwidth-estimate--sampling>6) Bandwidth estimate & sampling</a></li><li><a href=#7-example-hybrid-workflow>7) Example hybrid workflow</a></li></ul></li><li><a href=#practical-network-patterns--conservative-heuristics>Practical network patterns & conservative heuristics</a></li><li><a href=#persistence-reconcilation--authoritative-storage>Persistence, reconcilation & authoritative storage</a></li><li><a href=#monitoring--metrics-to-watch-closely>Monitoring & metrics to watch closely</a></li><li><a href=#tldr-architecture-checklist>TL;DR: architecture checklist</a></li><li><a href=#final-note-real-talk>Final note (real talk)</a></li></ul></nav></div></details></div><div class=post-content><hr><p>Building an MMORPG backend is like building a tiny distributed country where every player is a citizen, every NPC a bureaucrat, and latency is the weather. You design for scale, consistency, fairness, and - most importantly - fun. Below is one continuous, slightly nerdy walkthrough of the system-level decisions I’d make (and the gotchas I’d sweat about at 3 AM): edge compute, server topologies and authority, clock synchronization, spatial partitioning with quadtrees, and a focused deep-dive on cloth synchronization (yes, that ugly yet sexy problem).</p><blockquote><p>Note: some concepts and short references below mirror the “lag reduction” notes I carried into the project (edge/local zone patterns, load balancing strategies, lockstep vs rollback, client/server authority, etc.).</p></blockquote><hr><h2 id=the-shape-of-the-problem-correctness-vs-responsiveness>The shape of the problem: correctness vs responsiveness<a hidden class=anchor aria-hidden=true href=#the-shape-of-the-problem-correctness-vs-responsiveness>#</a></h2><p>Before we design anything: an MMO must answer two competing demands:</p><ol><li><strong>Correctness (authoritative state)</strong> - players shouldn&rsquo;t be able to cheat by lying about their position or health.</li><li><strong>Responsiveness (feel)</strong> - actions should feel instant even when your RTT is non-zero.</li></ol><p>Solving both means a layered approach: authoritative servers + client prediction + smart networked correction + edge placement.</p><hr><h2 id=edge-computing-bring-the-server-to-the-player>Edge computing: bring the server to the player<a hidden class=anchor aria-hidden=true href=#edge-computing-bring-the-server-to-the-player>#</a></h2><p>Edge compute reduces RTT by moving session-affine services closer to players. Practical building blocks:</p><ul><li><p><strong>Local Zones / Outposts</strong>: run full or partial game services in AWS Local Zones or Outposts when low-latency presence is needed in a metro. Useful for voice, matchmaking, and session brokering.</p></li><li><p><strong>Netflix OCAs-style appliances / on-prem edges</strong>: for very large events or regions with special constraints, local appliances can cache assets and reduce WAN hops.</p></li><li><p><strong>Edge responsibilities</strong>:</p><ul><li><strong>Session brokering & matchmaking</strong> (global service that picks a nearby edge host).</li><li><strong>Proximity servers</strong> - short-lived, regionally spawned authoritative instances for combat zones, raids, or sharded areas.</li><li><strong>Stateless frontends</strong> (auth, cosmetic inventory, marketplace) can run at the cloud edge with global DBs; heavy simulation runs on local stateful nodes.</li></ul></li></ul><p>Edge placement minimizes RTT for the critical loops (player input → server tick → response) while leaving durable, global services in centralized regions.</p><hr><h2 id=server-topologies--authority-modes>Server topologies & authority modes<a hidden class=anchor aria-hidden=true href=#server-topologies--authority-modes>#</a></h2><p>There are multiple topologies. Pick one (or mix them) based on game mechanics:</p><ol><li><p><strong>Central authoritative servers (classic)</strong></p><ul><li>Single authoritative instance per game region/zone.</li><li>Pros: simple consistency; server enforces rules.</li><li>Cons: higher latency for distant players; scaling by adding more regions/instances.</li></ul></li><li><p><strong>Sharded / zoning (cell-based)</strong></p><ul><li>The world is split into shards / cells; each cell has an authoritative server. Players move between cells (handoff). Cells can be assigned by a control plane (quadtrees, see below).</li><li>Pros: horizontal scaling, locality.</li><li>Cons: handoff complexity and cross-cell consistency.</li></ul></li><li><p><strong>Client-authoritative with server reconciliation (not for PvP)</strong></p><ul><li>Clients lead; servers validate. Good for low-cheat-risk elements like cosmetic sims. Not recommended for combat.</li></ul></li><li><p><strong>P2P / hybrid</strong></p><ul><li>Rare for MMOs due to trust/cheat surface. Often used for LAN/low-latency co-op.</li></ul></li><li><p><strong>Relay / regional authority</strong></p><ul><li>Clients connect to a local relay that aggregates inputs and forwards to a regional authority - useful when you want to reduce global WAN bandwidth but maintain a single authoritative state.</li></ul></li></ol><p><strong>Authority settings</strong> determine who finalizes state for a given domain:</p><ul><li><strong>Server-authoritative</strong> for game-critical things (position for hit detection, inventories, combat).</li><li><strong>Client-predicted, server-validated</strong> for movement: client shows immediate movement, server later corrects.</li><li><strong>Client-authoritative</strong> for purely cosmetic, local-only simulations (local cloth visual only if correctness not required).</li></ul><hr><h2 id=clock-synchronization--ticks-making-time-meaningful>Clock synchronization & ticks: making time meaningful<a hidden class=anchor aria-hidden=true href=#clock-synchronization--ticks-making-time-meaningful>#</a></h2><p>Time is the lingua franca of multiplayer. You need consistent ticks, determinism where possible, and latency-aware mapping.</p><h3 id=tick-model>Tick model<a hidden class=anchor aria-hidden=true href=#tick-model>#</a></h3><ul><li><strong>Server tick</strong> is the canonical clock (e.g., 20-60Hz depending on simulation fidelity). Every authoritative simulation step runs at server tick <code>T</code>.</li><li><strong>Client tick</strong> runs at a higher rate for rendering and local input sampling.</li></ul><p>Clients map server ticks to local time using periodic <strong>server snapshots</strong> with server timestamp <code>S_ts</code> and server tick <code>S_tick</code>. Client computes <code>clock_offset = local_now - S_ts - network_latency_estimate/2</code> and uses it to align.</p><h3 id=time-synchronization-techniques>Time synchronization techniques<a hidden class=anchor aria-hidden=true href=#time-synchronization-techniques>#</a></h3><ul><li><strong>Ping/Pong RTT estimation (NTP style)</strong>: measure RTT and estimate one-way delay; maintain offset with exponential smoothing. This is the simplest and often sufficient.</li><li><strong>Adaptive smoothing / Kalman filters</strong> to stabilize jittery latency.</li><li><strong>PTP-like methods</strong> for tighter sync if hosts are on the same LAN or data center - rarely practical across the public internet.</li><li><strong>Logical clocks & sequence numbers</strong> for ordering events (tx_id style) when absolute wall-clock sync is not required.</li></ul><h3 id=using-clocks-for-networking>Using clocks for networking<a hidden class=anchor aria-hidden=true href=#using-clocks-for-networking>#</a></h3><ul><li><strong>Server-side authoritative timestamping</strong>: server stamps accepted inputs with server_tick and broadcasts snapshots keyed by tick.</li><li><strong>Client interpolation / extrapolation</strong>: client renders server snapshot for tick <code>T - buffer</code> (buffer = 1-3 ticks) and interpolates between ticks to hide jitter. For fast actions, client extrapolates forward (prediction) and later reconciles with authoritative corrections.</li></ul><p>Pseudo timeline for client:</p><ol><li>Receive snapshot for server_tick <code>T</code> at local time <code>R</code>.</li><li><code>render_target_tick = latest_server_tick - render_buffer</code>.</li><li>Interpolate between snapshots for <code>render_target_tick</code>.</li></ol><hr><h2 id=network-techniques-interpolation-extrapolation-and-rollback>Network techniques: interpolation, extrapolation, and rollback<a hidden class=anchor aria-hidden=true href=#network-techniques-interpolation-extrapolation-and-rollback>#</a></h2><ul><li><strong>Interpolation</strong>: keep a short buffer and interpolate between known states. Great for position smoothing, avoids visible teleporting on low packet loss.</li><li><strong>Extrapolation / prediction</strong>: client simulates forward using local inputs. Server corrects if divergence exceeds threshold (snapback or smooth correction).</li><li><strong>Rollback (for deterministic sims / lockstep games)</strong>: store history of local inputs and simulation states, apply late-arriving inputs by rolling simulation forward - used in fighting games and lockstep RTS when determinism is strict. For MMOs, rollback is expensive due to state size, so we usually use reconciliation instead.</li></ul><p>Lockstep vs rollback vs server-authoritative:</p><ul><li><strong>Lockstep</strong> (deterministic): all peers run the same deterministic sim and exchange inputs. Low bandwidth but needs bit-exact determinism - hard for cloth and physics.</li><li><strong>Rollback</strong>: apply late inputs retroactively; requires checkpointing and often used in peer-fighting games.</li><li><strong>Server-authoritative</strong> with client prediction + reconciliation: most robust for MMO scale.</li></ul><hr><h2 id=spatial-partitioning-quadtrees-sharding-and-interest-management>Spatial partitioning: quadtrees, sharding, and interest management<a hidden class=anchor aria-hidden=true href=#spatial-partitioning-quadtrees-sharding-and-interest-management>#</a></h2><p>Partitioning the world by location is essential for scaling and interest management.</p><h3 id=quadtrees-for-location-based-partitioning>Quadtrees for location-based partitioning<a hidden class=anchor aria-hidden=true href=#quadtrees-for-location-based-partitioning>#</a></h3><p>Quadtrees recursively subdivide space into four quadrants until each leaf contains a manageable number of entities or covers a small area. Use-cases:</p><ul><li><strong>Interest management</strong>: query quadtree for radius or view-frustum to determine which entities a client needs.</li><li><strong>Server sharding</strong>: map quadtree leaves to authoritative servers or worker pools. When a leaf grows too hot, split it; when sparse, merge.</li><li><strong>Load balancing</strong>: use heatmaps to migrate hot leaves to more provisioned hosts.</li></ul><p>Quadtrees are simple and spatially adaptive. Implementation notes:</p><ul><li>Use <strong>loose quadtrees</strong> to avoid thrashing entities across boundaries.</li><li>Store metadata per node: entity count, CPU load estimate, bandwidth usage.</li><li>Handoff when a player crosses a node boundary: a short &ldquo;handoff protocol&rdquo; transfers authority and state and uses overlap regions during handoff to prevent gaps.</li></ul><h3 id=interest-management--multicast>Interest management & multicast<a hidden class=anchor aria-hidden=true href=#interest-management--multicast>#</a></h3><ul><li>Compute a <strong>relevance set</strong> per client using quadtree queries + LOD rules (NPCs beyond X meters get less frequent updates).</li><li>Use <strong>multicast groups or topic-based pub/sub</strong> to only send deltas to clients that care (spatial topics like <code>zone/leaf/123</code>).</li></ul><hr><h2 id=server-side-simulation-partitioning--authority-strategies>Server-side simulation: partitioning & authority strategies<a hidden class=anchor aria-hidden=true href=#server-side-simulation-partitioning--authority-strategies>#</a></h2><p>How to split simulation responsibilities:</p><ul><li><strong>Cell servers</strong>: authoritative for a spatial cell; responsible for physics & authoritative gameplay.</li><li><strong>Service workers</strong>: handle non-latency-critical tasks - AI pathfinding batch jobs, economy processing, persistence.</li><li><strong>Replica/reader nodes</strong>: read-only copies for analytics, leaderboards, or for cheap, eventual-consistent queries.</li></ul><p>When scaling, prefer <strong>stateful cells + stateless frontends</strong>. Cells are sticky to players; frontends route input to the correct cell. A matchmaking/control plane assigns cells and manages lifecycle.</p><hr><h2 id=load-balancing--provisioning-modes>Load balancing & provisioning modes<a hidden class=anchor aria-hidden=true href=#load-balancing--provisioning-modes>#</a></h2><p>From the slide notes: choose servers based on usage profile - reserved, on-demand, spot - and plan for autoscaling & pre-warming:</p><ul><li><strong>Reserved servers</strong> for persistent high-capacity regions/peak hours.</li><li><strong>On-demand</strong> for elasticity.</li><li><strong>Spot instances</strong> for cheap but replaceable workers (non-critical batch processing, analytics).</li><li><strong>Pre-warming</strong> or warm pools for game instances that must start fast (avoid spin-up latency during a raid).</li></ul><p>Load balancers should be proximity-aware and sticky at the session level when needed, but not for authoritative instances that must reject unauthenticated reroutes.</p><p>(See the “lag reduction” notes for a reminder that load balancing and edge placement are cornerstones of latency reduction.)</p><hr><h2 id=cloth-sync---deep-dive-the-spicy-one>Cloth sync - deep dive (the spicy one)<a hidden class=anchor aria-hidden=true href=#cloth-sync---deep-dive-the-spicy-one>#</a></h2><p>Cloth simulation is tricky: it&rsquo;s high-frequency, high-degree-of-freedom, and visually sensitive. You usually cannot naively stream per-vertex positions from server to clients - bandwidth explodes. Here’s a practical, layered strategy.</p><h3 id=1-decide-the-authority-model-for-cloth>1) Decide the authority model for cloth<a hidden class=anchor aria-hidden=true href=#1-decide-the-authority-model-for-cloth>#</a></h3><p>Options:</p><ul><li><strong>Client-only (visual-only)</strong> - the server ignores cloth entirely. Good for cosmetics where gameplay is unaffected.</li><li><strong>Server-authoritative physics</strong> - server runs cloth sim and sends authoritative states; needed if cloth affects gameplay (e.g., entanglement, hitboxes).</li><li><strong>Hybrid</strong> - server authorizes key constraints/anchors; clients run local sims for rendering and reconcile to authoritative constraints.</li></ul><p>For MMORPGs, hybrid is usually the sweet spot: server maintains anchors and critical collisions; clients predict local cloth motion for smooth visuals.</p><h3 id=2-represent-cloth-efficiently>2) Represent cloth efficiently<a hidden class=anchor aria-hidden=true href=#2-represent-cloth-efficiently>#</a></h3><p>Network transfers should avoid per-frame full-vertex dumps. Use these techniques:</p><ul><li><strong>Anchor/constraint sync</strong>: send only anchor points and constraint updates (rest lengths, impulses). Clients simulate cloth locally using those anchors.</li><li><strong>Lodded vertex sets</strong>: send a high-frequency small core set of “driver” vertices and low-frequency deltas for the rest.</li><li><strong>Principal component / PCA compression</strong>: encode cloth frames in a low-rank basis (approximate by a few coefficients per frame). Great if cloth moves in a constrained manner (capes, flags).</li><li><strong>Delta + predictive coding</strong>: send deltas relative to predicted local sim to save bandwidth.</li></ul><h3 id=3-determinism-vs-stochasticity>3) Determinism vs stochasticity<a hidden class=anchor aria-hidden=true href=#3-determinism-vs-stochasticity>#</a></h3><ul><li>Use <strong>fixed timestep</strong> local sims (e.g., 120Hz physics loop) and deterministic integrators (semi-implicit Euler, Verlet with fixed order) so client sim mirrors server sim as closely as possible.</li><li>Use shared RNG seed for stochastic forces (wind gusts) so clients and server can reproduce pseudo-random influences deterministically.</li></ul><h3 id=4-correction--reconciliation>4) Correction & reconciliation<a hidden class=anchor aria-hidden=true href=#4-correction--reconciliation>#</a></h3><p>Even with careful design, client sim drifts. Reconciliation strategy:</p><ul><li><strong>Authority snapshots</strong>: server sends periodic authoritative &ldquo;keyframes&rdquo; with a server_tick timestamp and a small correction envelope.</li><li><strong>Blend corrections</strong>: clients smoothly blend from local state to authoritative state over <code>k</code> frames rather than snapping. Use velocity-preserving blends when possible to avoid pops.</li><li><strong>Constraint projection</strong>: server sends constraint corrections (e.g., anchor position corrections or per-constraint stretching penalties). Clients apply these as impulses rather than overwriting positions.</li></ul><p>Snippet (pseudo) for client correction blend:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// acolor: authoritative positions; local: predicted
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=nx>i</span> <span class=k>in</span> <span class=mf>0.</span><span class=p>.</span><span class=nx>num_verts</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=nx>delta</span> <span class=o>=</span> <span class=nx>authoritative</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>-</span> <span class=nx>local</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=nx>local</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>+=</span> <span class=nx>delta</span> <span class=o>*</span> <span class=nx>clamp</span><span class=p>(</span> <span class=nx>alpha</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span> <span class=p>)</span>  <span class=c1>// alpha small, e.g., 0.1
</span></span></span></code></pre></div><h3 id=5-multi-resolution-streaming>5) Multi-resolution streaming<a hidden class=anchor aria-hidden=true href=#5-multi-resolution-streaming>#</a></h3><ul><li><strong>High-prio</strong>: anchor vertices, collision-critical verts (near player weapon), per-frame.</li><li><strong>Mid-prio</strong>: silhouette vertices, every N frames.</li><li><strong>Low-prio</strong>: interior vertices, sparse updates or PCA-coded updates.</li></ul><h3 id=6-bandwidth-estimate--sampling>6) Bandwidth estimate & sampling<a hidden class=anchor aria-hidden=true href=#6-bandwidth-estimate--sampling>#</a></h3><p>Tune:</p><ul><li>Anchor-only mode: few KB/s per cloth.</li><li>Full per-vertex sync (bad): MB/s per client.</li><li>PCA/delta approach: tens to hundreds of KB/s depending on frequency.</li></ul><h3 id=7-example-hybrid-workflow>7) Example hybrid workflow<a hidden class=anchor aria-hidden=true href=#7-example-hybrid-workflow>#</a></h3><ol><li>Server computes anchor positions + collision impulses each authoritative tick.</li><li>Clients simulate local cloth at render rate, sampling server anchors on arrival.</li><li>On authoritative tick, server sends corrections for anchors & important constraints; clients apply blended corrections.</li><li>Periodic keyframes (vector-compressed or PCA) re-sync full shape if drift exceeds threshold.</li></ol><p>This gets visually-close cloth with manageable bandwidth and server CPU. If cloth affects gameplay, raise server tick and authority; if cosmetic, favor client-only sim and occasional server nudges.</p><hr><h2 id=practical-network-patterns--conservative-heuristics>Practical network patterns & conservative heuristics<a hidden class=anchor aria-hidden=true href=#practical-network-patterns--conservative-heuristics>#</a></h2><ul><li><strong>Interest-based update frequency</strong>: players near a cloth source get full updates; distant players get coarse LOD.</li><li><strong>Thresholded corrections</strong>: only send full state if drift > epsilon.</li><li><strong>Predictive drift compensation</strong>: server provides velocity/acceleration for anchors so clients can predict until next update.</li><li><strong>Compression + binary protocols</strong>: use compact binary frames (VarInt, delta-encoding) and consider protocol buffers / custom COBS to minimize packets.</li></ul><hr><h2 id=persistence-reconcilation--authoritative-storage>Persistence, reconcilation & authoritative storage<a hidden class=anchor aria-hidden=true href=#persistence-reconcilation--authoritative-storage>#</a></h2><p>For MMO scale, persistence strategy:</p><ul><li><strong>Authoritative snapshots</strong> persisted periodically (checkpoints) to durable storage.</li><li><strong>Event sourcing</strong> for important game mutations (player trades, inventory changes) so you can replay and backfill.</li><li><strong>Soft state for visuals</strong> such as cloth usually does not persist beyond session, unless tied to gameplay.</li></ul><p>Backfills and rollbacks must be deterministic and replayable. If a shard fails, replay CDC-like event logs to bring replicas up-to-date.</p><hr><h2 id=monitoring--metrics-to-watch-closely>Monitoring & metrics to watch closely<a hidden class=anchor aria-hidden=true href=#monitoring--metrics-to-watch-closely>#</a></h2><ul><li><strong>Server tick time</strong> (ms) and drops (missed ticks).</li><li><strong>Network jitter & packet loss</strong> per client region.</li><li><strong>State divergence metrics</strong> (client vs server error histograms).</li><li><strong>Memory use for state backends</strong> (e.g., per-cell cloth cache).</li><li><strong>Hotspot detection</strong> to trigger dynamic quadtree splits.</li></ul><hr><h2 id=tldr-architecture-checklist>TL;DR: architecture checklist<a hidden class=anchor aria-hidden=true href=#tldr-architecture-checklist>#</a></h2><ul><li>Use <strong>edge/local zones</strong> for low-latency session brokering and proximity servers.</li><li>Pick <strong>server topology</strong>: cell-based authoritative servers + stateless frontends is a pragmatic choice.</li><li>Sync time by <strong>server ticks + ping-based offset estimation</strong>; render with interpolation and prediction.</li><li>Partition world with <strong>loose quadtrees</strong> for adaptive sharding and interest management.</li><li>Build <strong>handoff protocols</strong> for smooth cross-node migration.</li><li>For cloth: prefer <strong>hybrid authority</strong> (anchors server, local sim client), compress state (anchor-only, PCA, deltas), and reconcile with blended corrections.</li><li>Use <strong>reserved + on-demand + spot</strong> provisioning strategies and warm pools for fast scaling.</li></ul><hr><h2 id=final-note-real-talk>Final note (real talk)<a hidden class=anchor aria-hidden=true href=#final-note-real-talk>#</a></h2><p>The art of MMO backend engineering is picking the parts you can operationally own. Don’t try to make every system deterministic across all edge cases - instead, identify <em>what must be right</em> (combat hits, inventory), <em>what must feel right</em> (movement, cloth, VFX), and <em>what can be eventual</em> (leaderboards, analytics). Combine server-authoritative systems for correctness with prediction and local sims for feel. Use edge compute and quadtrees for locality. Make cloth a hybrid problem: clever compression + deterministic cores + smooth corrections. And, most importantly, instrument everything - your best sleep comes from good metrics, not superstition.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/notes/>Notes</a></li><li><a href=http://localhost:1313/tags/game-dev/>Game-Dev</a></li><li><a href=http://localhost:1313/tags/mmorpg/>Mmorpg</a></li><li><a href=http://localhost:1313/tags/netcode/>Netcode</a></li><li><a href=http://localhost:1313/tags/edge-computing/>Edge-Computing</a></li><li><a href=http://localhost:1313/tags/spatial-partitioning/>Spatial-Partitioning</a></li><li><a href=http://localhost:1313/tags/cloth/>Cloth</a></li><li><a href=http://localhost:1313/tags/backend/>Backend</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/galaxy-zooing-my-first-cnn/><span class=title>« Prev</span><br><span>PROJECT: Galaxy Zooing my first CNN</span>
</a><a class=next href=http://localhost:1313/posts/lgtm-stack-or-die/><span class=title>Next »</span><br><span>NOTES: Lgtm Stack or Die</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>T|A</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>